---
layout:     post             # layout, do not alter
title:      校招准备          # title
subtitle:   C/C++基础（1）    # subtitle
date:       2018-8-17         # time
author:     xSun             # author
header-img: img/DSC_4446.jpg  #bg image
catalog: true                # catalog or not
tags:                        #tags
    - 校招
    - C/C++
---

> 这几个月来，一直在准备校招，零零碎碎的从各个渠道也总结了很多知识点，现在进行一下整理，一方面是对自己的交代，另一方面也希望可以给别人提供参考。

## 基础原理

### 进程地址空间布局
以32位为例，进程的用户地址空间布局大致如下图所示。
![process_space](http://p194hb5ge.bkt.clouddn.com/process_space.jpg)
[参考链接][2]

段|说明
:----:|:------------------------------------:
BSS |	静态存储区的一部分，用来存放未初始化的全局变量
数据段|	静态存储区的一部分，用来存储已初始化的全局变量和static声明的变量
代码段|存放程序代码的内存区，为程序代码在内存中的映射
堆|	为变量动态分配内存的区域，堆区大小不固定
栈|存放程序的局部变量和形参，函数调用时栈用来传递参数和返回值
动态存储区|堆，栈
静态存储区|BSS，数据段

查看进程地址映射可以使用 **cat /proc/pid/maps**命令，即就是查看maps文件，可以看到此进程所关联的vma的情况，包括地址范围，读取权限，映射文件等。如下图：

![process_maps](http://p194hb5ge.bkt.clouddn.com/process_maps.png)

**由输出并结合上图可知，如果在程序里访问NULL指针，会产生core dump，因为在进程地址空间中[0, 400000]此段为未映射，不属于该进程地址空间内。**

> 如果产生coredump，可以使用gdb进行调试。首先需要使用命令`ulimit -c unlimited`使得系统产生coredump文件，然后直接使用`gdb ./coredumpfilename`进程调试即可，可以找到发生segment fault的位置等。

静态变量（静态局部变量，静态全局变量）和全局变量都位于**静态存储区**，他们的共同特点是生存周期贯穿于真个程序执行过程。区别在于作用范围不同，全局变量可作用于所有的函数，静态变量只能用于所定义的函数。

**int 型全局变量，静态局部变量的初始值都为0。
int型的局部变量的初始值为随机值。
要在一个文件中使用与局部变量同名的全局变量，需要加上：：**



```
#include <stdio.h>
int BSS; //存储在BSS区
Static char * p; // BSS
int data = 10; //存储在数据段，其他文件中可使用 extern 声明
Static char * q = "abc"; 
//q在数据区，“abc"在文本常量区，值不能修改, 作用域只在本文件内
int main
{
	static int a = 20; //存储在数据段
	int x, y; // 存储在栈上
	char *p = (char *)malloc(20); //存储在堆上
	int b = foo(x,y); //用栈进行参数传递
	int data = 30;
	printf("%d\n",::data); //访问与局部变量同名全局变量
	free(p);
	return 0;
}
int foo( int x, int y)
{
	int b = x + y;
	return b; // 返回值存储在eax寄存器中
}

```
---

## 堆 & 栈
栈区(stack) -- 由编译器自动分配和释放，存放函数的参数值，局部变量的值等。其操作方式类似于数据结构中的栈。

堆区(heap) -- 一般由程序员分配和释放，若程序员不释放，程序结束时可能由OS回收，注意它与数据结构中的堆是两回事，分配方式倒是类似于链表。

### 堆、栈区别
- 按管理方式 
	- 栈是系统编译器启动管理，不需要程序员手动管理
	- 堆的释放由程序员手动管理，不及时回收容易产生内存泄露
- 按分配方式 
	- 栈静态分配是系统编译器完成的，比如局部变量的分配
	- 堆是动态分配和回收内存的，没有静态分配的堆
- 按分配大小 
	- 栈是向低地址扩展的数据结构，是一块连续的内存区域
   - 堆是向高地址扩展的数据结构，是不连续的内存区域

> > 如何溢出栈？
 1. 递归函数无限递归
 2. 使用大结构的局部变量

---

## const关键字
`const`为只读关键字，修饰的那个部分是只读的。

```
e.g.
int a = 10;
const int * p = &a; 表示p指向量a为只读 底层const
int const * p = &a; 同上
int * const p = &a; 表示指针p为只读  顶层const
const int* const d  指针和指向的内存区，二者都是只读的
```
### C++常量折叠

```
const int i = 0;
int *j = (int *)&i;
*j = 1;
cout << i << " " << *j << endl;

output:
0 1
```
C++中，const变量(即常量)值放在编译器的符号表中，计算时编译器直接从表中取值，而不是访问内存，省去了访问内存的时间，这也就是所谓的编译器优化。使用`volatile`关键字会强制从内存中取值，而不使用编译器的优化。

---

## sizeof关键字
sizeof 返回的值表示的含义如下（单位字节）:

类别|大小
:---:|:---:
数组 | 编译时分配的数组的内存大小 
指针 | 存储该指针所用的空间大小（32位是4，64位是8）
形参中的数组名 | 同指针
类   | 该类型所占的空间大小，不包括函数，只看成员变量及虚函数指针 
对象 | 对象的实际占用空间大小（考虑4/8字节对其）
函数 | 函数的返回类型所占的空间大小。函数的返回类型不能是void 

```
空类：
class CBase{
};
sizeof(CBase) == 1;
```
《深度探索c++对象模型》中是这样说的：那是被编译器插进去的一个char，使得这个class的不同实体（object）在内存中配置独一无二的地址。也就是说这个char是用来标识类的不同对象的。

---


[^_^]: refs here:

[1]:http://www.xsun24.top/
[2]:http://www.cnblogs.com/clover-toeic/p/3754433.html
